---
layout: post
title:  "CoreData 개념 정리"
date:   2018-03-23 01:02:21 +0900
categories: ios
author : yckim
---


### 1. Core Data 정의
##### 애플리케이션에서 모델 계층의 객체를 관리하는데 사용하는 프레임워크이자, 라이프 사이클이나 영속성 관리를 위한 기능을 제공하는 객체 그래프 관리자

### 2. Core Data 오해
##### 흔히들 데이터베이스 그자체 또는 SQLite의 래퍼 정도로 알고 있지만 인메모리 방식으로 영구 저장소를 아예 사용하지 않고도 쓸수 있기 때문에 데이터베이스나 SQLite의 래퍼로 보기는 힘들고 자바의 하이버네이트와 같은 ORM 매핑 프레임워크에 더 가깝다.

### 3. Core Data 구조
 * 관리 객체 모델(Managed Object Model) : DB로 치면 스키마의 해당하는 것
 - 관리 객체(Managed Object) : 코어데이터에서 데이터를 저장하기 위해 생성하는 인스턴스
 - 관리 객체 컨텍스트(Managed Object Context) : 가장 핵심적인 객체. DAO클래스의 역할, 실제로 우리가 핸들링 해야할 대상입니다.
 - 영구 저장소 코디네이터(Persistent Store Coordinator) : 컨텍스트와 직접 데이터를 주고 받으면서 저장소의 대한 실제 입출력을 담당. 모든 과정은 자동으로 처리되므로 우리가 핸들링 할 경우는 거의 없습니다.
 - 영구 객체 저장소(Persistant Object Store) : 실제도 데이터가 저장되는 저장소. 4가지 타입이 존재

구분|설명
---|---
NSInmemoryStoreType(인메모리)|메모리 기반의 저장소 방식. 앱 종료시 데이터가 보존되지 않음 데이터 객체의 런타임 캐싱에 활용
NSBinaryStoreType(플랫 바이너리 저장소)|단순 바이너리 파일 형식으로 저장하는 방식. 데이터 조회 성능을 개선할 수 있지만,데이터의 크기가 커질수록 파일의 크기가 커지고  초기 로딩시간이 늘어남
NSXMLStoreType(XML 저장소)|XML형식의 파일로 저장하는 방식. 항상 전체가 저장되거나 저장되지 않는 원자성을 가짐. 처리속도가 느리지만 코드를 열어볼수 있어서 디버깅 및 저장여부 확인이 필요할 때 많이 사용되며 IOS에서는 속도 및 성능 제약으로 사용불가능.
NSSQLiteStoreType(SQLite 데이터베이스)|가장 많이 쓰는 영구 저장소 타입. 일부만 로딩하기 때문에 메모리에 객체 그래프가 완전히 로딩되어 있지 않을 수 있습니다.

##### __어떤 타입을 선택해도 CoreData의 API는 달라지지 않으며 이는 영구 저장소 타입을 쉽게 변경할 수 있다는 뜻입니다.__

### 4. 데이터의 교환 및 저장 메커니즘
구분|설명
-|-
SQLite 저장소|	차등저장(Differencial Save) 매커니즘 사용. 매번 전체를 커밋하는 대신 마지막 저장이후에 변경된 부분만 커밋하는 방식. 빠르고 가볍게 처리가능
그외 저장소|	프로퍼티 리스트처럼 개별 데이터를 일일이 저장할 필요 없이, 메모리상에서 컨텍스트에 로드된 관리객체를 커밋하면 변경사항이 통째로 영구저장소에 반영됨.

### 5. Core Data 한계
- 데이터를 메모리에 로딩하는 과정 없이는 작업이 불가능 (인메모리방식이기 때문)
- 데이터 로직을 다루는 데에 한계가 있다.
  * 대표적으로 코어데이터에는 Unique 기능이 없음.
  * 코어데이터의 구조적 특성 때문. 관리 객체 모델을 서브 클래싱(상속?) 하는 경우 원하는대로 데이터 프로퍼티에 대한 오버라이드가 가능한데 이를 통해 변경된 내용을 코어데이터가 확인할 수 있는 방법이 없음.
- 멀티스레드, 멀티유저를 지원하지 않지만 IOS의 애플리케이션은 대부분 싱글유저 환경이므로 싱글스레드만으로도 충분하다고 합니다.
